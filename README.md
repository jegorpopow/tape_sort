# tape_sort

## Сборка и запуск

```bash
cmake .
make
./tape_sort tape_sort <tape to sort> <destination>      # консольное приложение
ulimit -n <4096 или другое достаточно большое число>    # опционально увеличиваем лимит количества файловых дескрипторов (это может быть нужно для большого теста алгоритма c простым разбиением на блоки) 
./tests                                                 # тесты
```

Формат `config`-а:
5 чисел(размер оперативной памяти M, задержки чтения, записи, сдвига и перемотки, 
разделённые пробельными символами). Можно указать свой config при запуске, дефолтное
имя `.tape-config`

## Алгоритмы 

Представлено 2 алгоритма для сортировки ленты (первый является простым частным случаем второго)

### Сортировка в оперативной памяти (метод `sorter::`)

Мы разбиваем содержимое нашей ленты на участки, помещающиеся в оперативную память, последовательно считываем и сортируем в оперативной памяти 
эти участки, сохраняем каждый из них на отдельную ленту, после чего объединяем эти отстортированные отрезки в результат, как в mergesort. 

В итоге мы выполняем $4N = O(N)$ операций чтения/записи на ленту и $O(\frac{N}{M} \cdot M \log(M) + N\cdot \log \frac{N}{M}) = O(N\log N)$ операций для 
сортировки в оперативной памяти (предполагается, что эти операции значительно быстрее работы с лентой, поэтому их асимптотика не столь важна). 
Сортировка стабильна в зависимости от того, стабилен ли вызываемый ею алгоритм сортировки в опертивной памяти.

### Balanced merge sort(метод `sorter::`)

Расширение предыдущего алгоритма, позволяющее использовать заранее определённое константное число дополнительных лент $2P, p \leqslant 2$.

Поддерживаем следующую структуру - на $P$ лентах записаны остортированные блоки размера $K$ (по несколько на каждой ленте, последний может быть не полным), 
остальные $P$ не заняты полезной информацией. Мёржим первый (самый левый) блок с каждой из $P$ лент в блок размера $P\cdot K$, записывая его на одну из 
незанятых лент. Повторяем со вторым блоком и т.д., равномерно заполняя незаняты ленты. В результате получаем исходную картину, но на другом подмножестве 
лент и с блоками размера $P\cdot K$. Повторяем, пока весь массив не влезет в один блок.

Изначально считываем исходную последовательность по блокам, помещающимся в опертивную память, сортируем блоки и равномерно распеределяем по $P$ 
дополнительным лентам.

Всего ожидается $O(\log_P(\frac{N}{M}))$ итераций (т.к. размер блока на $i$-ой - $MP^i$), каждая представляет собой линейный проход по ленте. 
(Итого $2\cdot (1 + \lceil \log_P(\frac{N}{M}) \rceil)$ операций чтения/записи на ленту). 




